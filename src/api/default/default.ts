/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * Keyo API
 * API for Keyo Polls app
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import { customInstance } from '.././custom-instance';
import type { BodyType, ErrorType } from '.././custom-instance';
import type {
  ArticleDetails,
  ArticlesList,
  ChangeRoleRequestSchema,
  CompleteGoogleRegistrationResponseSchema,
  CompleteGoogleRegistrationSchema,
  CompleteRegistrationResponseSchema,
  CompleteRegistrationSchema,
  GoogleSignInResponseSchema,
  GoogleSignInSchema,
  KeyopollsArticlesApiCreateArticleBody,
  KeyopollsArticlesApiListArticlesParams,
  KeyopollsArticlesApiUpdateArticleBody,
  KeyopollsChatsApiServicesCreateServiceBody,
  KeyopollsChatsApiServicesGetServicesParams,
  KeyopollsChatsApiServicesUpdateServiceBody,
  KeyopollsChatsApiServicesUpdateServiceParams,
  LoginResponseSchema,
  LoginSchema,
  Message,
  SendOTPResponseSchema,
  SendOTPSchema,
  ServiceResponseSchema,
  ServicesListResponseSchema,
  UsernameAvailabilitySchema,
  VerifyOTPResponseSchema,
  VerifyOTPSchema,
} from '.././schemas';

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Handle Google Sign-In - creates incomplete profile requiring completion
 * @summary Google Signin
 */
export const keyopollsProfileApiAuthGoogleSignin = (
  googleSignInSchema: BodyType<GoogleSignInSchema>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<GoogleSignInResponseSchema>(
    {
      url: `/api/user/auth/google`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: googleSignInSchema,
      signal,
    },
    options
  );
};

export const getKeyopollsProfileApiAuthGoogleSigninMutationOptions = <
  TError = ErrorType<Message>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof keyopollsProfileApiAuthGoogleSignin>>,
    TError,
    { data: BodyType<GoogleSignInSchema> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof keyopollsProfileApiAuthGoogleSignin>>,
  TError,
  { data: BodyType<GoogleSignInSchema> },
  TContext
> => {
  const mutationKey = ['keyopollsProfileApiAuthGoogleSignin'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof keyopollsProfileApiAuthGoogleSignin>>,
    { data: BodyType<GoogleSignInSchema> }
  > = (props) => {
    const { data } = props ?? {};

    return keyopollsProfileApiAuthGoogleSignin(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type KeyopollsProfileApiAuthGoogleSigninMutationResult = NonNullable<
  Awaited<ReturnType<typeof keyopollsProfileApiAuthGoogleSignin>>
>;
export type KeyopollsProfileApiAuthGoogleSigninMutationBody = BodyType<GoogleSignInSchema>;
export type KeyopollsProfileApiAuthGoogleSigninMutationError = ErrorType<Message>;

/**
 * @summary Google Signin
 */
export const useKeyopollsProfileApiAuthGoogleSignin = <
  TError = ErrorType<Message>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof keyopollsProfileApiAuthGoogleSignin>>,
      TError,
      { data: BodyType<GoogleSignInSchema> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof keyopollsProfileApiAuthGoogleSignin>>,
  TError,
  { data: BodyType<GoogleSignInSchema> },
  TContext
> => {
  const mutationOptions = getKeyopollsProfileApiAuthGoogleSigninMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Send OTP for email verification
 * @summary Send Otp
 */
export const keyopollsProfileApiAuthSendOtp = (
  sendOTPSchema: BodyType<SendOTPSchema>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<SendOTPResponseSchema>(
    {
      url: `/api/user/auth/send-otp`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: sendOTPSchema,
      signal,
    },
    options
  );
};

export const getKeyopollsProfileApiAuthSendOtpMutationOptions = <
  TError = ErrorType<Message>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof keyopollsProfileApiAuthSendOtp>>,
    TError,
    { data: BodyType<SendOTPSchema> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof keyopollsProfileApiAuthSendOtp>>,
  TError,
  { data: BodyType<SendOTPSchema> },
  TContext
> => {
  const mutationKey = ['keyopollsProfileApiAuthSendOtp'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof keyopollsProfileApiAuthSendOtp>>,
    { data: BodyType<SendOTPSchema> }
  > = (props) => {
    const { data } = props ?? {};

    return keyopollsProfileApiAuthSendOtp(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type KeyopollsProfileApiAuthSendOtpMutationResult = NonNullable<
  Awaited<ReturnType<typeof keyopollsProfileApiAuthSendOtp>>
>;
export type KeyopollsProfileApiAuthSendOtpMutationBody = BodyType<SendOTPSchema>;
export type KeyopollsProfileApiAuthSendOtpMutationError = ErrorType<Message>;

/**
 * @summary Send Otp
 */
export const useKeyopollsProfileApiAuthSendOtp = <TError = ErrorType<Message>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof keyopollsProfileApiAuthSendOtp>>,
      TError,
      { data: BodyType<SendOTPSchema> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof keyopollsProfileApiAuthSendOtp>>,
  TError,
  { data: BodyType<SendOTPSchema> },
  TContext
> => {
  const mutationOptions = getKeyopollsProfileApiAuthSendOtpMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Verify OTP
 * @summary Verify Otp
 */
export const keyopollsProfileApiAuthVerifyOtp = (
  verifyOTPSchema: BodyType<VerifyOTPSchema>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<VerifyOTPResponseSchema>(
    {
      url: `/api/user/auth/verify-otp`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: verifyOTPSchema,
      signal,
    },
    options
  );
};

export const getKeyopollsProfileApiAuthVerifyOtpMutationOptions = <
  TError = ErrorType<Message>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof keyopollsProfileApiAuthVerifyOtp>>,
    TError,
    { data: BodyType<VerifyOTPSchema> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof keyopollsProfileApiAuthVerifyOtp>>,
  TError,
  { data: BodyType<VerifyOTPSchema> },
  TContext
> => {
  const mutationKey = ['keyopollsProfileApiAuthVerifyOtp'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof keyopollsProfileApiAuthVerifyOtp>>,
    { data: BodyType<VerifyOTPSchema> }
  > = (props) => {
    const { data } = props ?? {};

    return keyopollsProfileApiAuthVerifyOtp(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type KeyopollsProfileApiAuthVerifyOtpMutationResult = NonNullable<
  Awaited<ReturnType<typeof keyopollsProfileApiAuthVerifyOtp>>
>;
export type KeyopollsProfileApiAuthVerifyOtpMutationBody = BodyType<VerifyOTPSchema>;
export type KeyopollsProfileApiAuthVerifyOtpMutationError = ErrorType<Message>;

/**
 * @summary Verify Otp
 */
export const useKeyopollsProfileApiAuthVerifyOtp = <
  TError = ErrorType<Message>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof keyopollsProfileApiAuthVerifyOtp>>,
      TError,
      { data: BodyType<VerifyOTPSchema> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof keyopollsProfileApiAuthVerifyOtp>>,
  TError,
  { data: BodyType<VerifyOTPSchema> },
  TContext
> => {
  const mutationOptions = getKeyopollsProfileApiAuthVerifyOtpMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Complete Google registration after initial sign-in
 * @summary Complete Google Registration
 */
export const keyopollsProfileApiAuthCompleteGoogleRegistration = (
  completeGoogleRegistrationSchema: BodyType<CompleteGoogleRegistrationSchema>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<CompleteGoogleRegistrationResponseSchema>(
    {
      url: `/api/user/auth/complete-google-registration`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: completeGoogleRegistrationSchema,
      signal,
    },
    options
  );
};

export const getKeyopollsProfileApiAuthCompleteGoogleRegistrationMutationOptions = <
  TError = ErrorType<Message>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof keyopollsProfileApiAuthCompleteGoogleRegistration>>,
    TError,
    { data: BodyType<CompleteGoogleRegistrationSchema> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof keyopollsProfileApiAuthCompleteGoogleRegistration>>,
  TError,
  { data: BodyType<CompleteGoogleRegistrationSchema> },
  TContext
> => {
  const mutationKey = ['keyopollsProfileApiAuthCompleteGoogleRegistration'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof keyopollsProfileApiAuthCompleteGoogleRegistration>>,
    { data: BodyType<CompleteGoogleRegistrationSchema> }
  > = (props) => {
    const { data } = props ?? {};

    return keyopollsProfileApiAuthCompleteGoogleRegistration(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type KeyopollsProfileApiAuthCompleteGoogleRegistrationMutationResult = NonNullable<
  Awaited<ReturnType<typeof keyopollsProfileApiAuthCompleteGoogleRegistration>>
>;
export type KeyopollsProfileApiAuthCompleteGoogleRegistrationMutationBody =
  BodyType<CompleteGoogleRegistrationSchema>;
export type KeyopollsProfileApiAuthCompleteGoogleRegistrationMutationError = ErrorType<Message>;

/**
 * @summary Complete Google Registration
 */
export const useKeyopollsProfileApiAuthCompleteGoogleRegistration = <
  TError = ErrorType<Message>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof keyopollsProfileApiAuthCompleteGoogleRegistration>>,
      TError,
      { data: BodyType<CompleteGoogleRegistrationSchema> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof keyopollsProfileApiAuthCompleteGoogleRegistration>>,
  TError,
  { data: BodyType<CompleteGoogleRegistrationSchema> },
  TContext
> => {
  const mutationOptions =
    getKeyopollsProfileApiAuthCompleteGoogleRegistrationMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Complete registration after OTP verification
 * @summary Complete Registration
 */
export const keyopollsProfileApiAuthCompleteRegistration = (
  completeRegistrationSchema: BodyType<CompleteRegistrationSchema>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<CompleteRegistrationResponseSchema>(
    {
      url: `/api/user/auth/complete-registration`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: completeRegistrationSchema,
      signal,
    },
    options
  );
};

export const getKeyopollsProfileApiAuthCompleteRegistrationMutationOptions = <
  TError = ErrorType<Message>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof keyopollsProfileApiAuthCompleteRegistration>>,
    TError,
    { data: BodyType<CompleteRegistrationSchema> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof keyopollsProfileApiAuthCompleteRegistration>>,
  TError,
  { data: BodyType<CompleteRegistrationSchema> },
  TContext
> => {
  const mutationKey = ['keyopollsProfileApiAuthCompleteRegistration'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof keyopollsProfileApiAuthCompleteRegistration>>,
    { data: BodyType<CompleteRegistrationSchema> }
  > = (props) => {
    const { data } = props ?? {};

    return keyopollsProfileApiAuthCompleteRegistration(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type KeyopollsProfileApiAuthCompleteRegistrationMutationResult = NonNullable<
  Awaited<ReturnType<typeof keyopollsProfileApiAuthCompleteRegistration>>
>;
export type KeyopollsProfileApiAuthCompleteRegistrationMutationBody =
  BodyType<CompleteRegistrationSchema>;
export type KeyopollsProfileApiAuthCompleteRegistrationMutationError = ErrorType<Message>;

/**
 * @summary Complete Registration
 */
export const useKeyopollsProfileApiAuthCompleteRegistration = <
  TError = ErrorType<Message>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof keyopollsProfileApiAuthCompleteRegistration>>,
      TError,
      { data: BodyType<CompleteRegistrationSchema> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof keyopollsProfileApiAuthCompleteRegistration>>,
  TError,
  { data: BodyType<CompleteRegistrationSchema> },
  TContext
> => {
  const mutationOptions = getKeyopollsProfileApiAuthCompleteRegistrationMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Login with email or username and password
 * @summary Login
 */
export const keyopollsProfileApiAuthLogin = (
  loginSchema: BodyType<LoginSchema>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<LoginResponseSchema>(
    {
      url: `/api/user/auth/login`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: loginSchema,
      signal,
    },
    options
  );
};

export const getKeyopollsProfileApiAuthLoginMutationOptions = <
  TError = ErrorType<Message>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof keyopollsProfileApiAuthLogin>>,
    TError,
    { data: BodyType<LoginSchema> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof keyopollsProfileApiAuthLogin>>,
  TError,
  { data: BodyType<LoginSchema> },
  TContext
> => {
  const mutationKey = ['keyopollsProfileApiAuthLogin'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof keyopollsProfileApiAuthLogin>>,
    { data: BodyType<LoginSchema> }
  > = (props) => {
    const { data } = props ?? {};

    return keyopollsProfileApiAuthLogin(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type KeyopollsProfileApiAuthLoginMutationResult = NonNullable<
  Awaited<ReturnType<typeof keyopollsProfileApiAuthLogin>>
>;
export type KeyopollsProfileApiAuthLoginMutationBody = BodyType<LoginSchema>;
export type KeyopollsProfileApiAuthLoginMutationError = ErrorType<Message>;

/**
 * @summary Login
 */
export const useKeyopollsProfileApiAuthLogin = <TError = ErrorType<Message>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof keyopollsProfileApiAuthLogin>>,
      TError,
      { data: BodyType<LoginSchema> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof keyopollsProfileApiAuthLogin>>,
  TError,
  { data: BodyType<LoginSchema> },
  TContext
> => {
  const mutationOptions = getKeyopollsProfileApiAuthLoginMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Check if username is available
 * @summary Check Username Availability
 */
export const keyopollsProfileApiAuthCheckUsernameAvailability = (
  username: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<UsernameAvailabilitySchema>(
    { url: `/api/user/auth/check-username/${username}`, method: 'GET', signal },
    options
  );
};

export const getKeyopollsProfileApiAuthCheckUsernameAvailabilityQueryKey = (username: string) => {
  return [`/api/user/auth/check-username/${username}`] as const;
};

export const getKeyopollsProfileApiAuthCheckUsernameAvailabilityQueryOptions = <
  TData = Awaited<ReturnType<typeof keyopollsProfileApiAuthCheckUsernameAvailability>>,
  TError = ErrorType<Message>,
>(
  username: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof keyopollsProfileApiAuthCheckUsernameAvailability>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getKeyopollsProfileApiAuthCheckUsernameAvailabilityQueryKey(username);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof keyopollsProfileApiAuthCheckUsernameAvailability>>
  > = ({ signal }) =>
    keyopollsProfileApiAuthCheckUsernameAvailability(username, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!username, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof keyopollsProfileApiAuthCheckUsernameAvailability>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type KeyopollsProfileApiAuthCheckUsernameAvailabilityQueryResult = NonNullable<
  Awaited<ReturnType<typeof keyopollsProfileApiAuthCheckUsernameAvailability>>
>;
export type KeyopollsProfileApiAuthCheckUsernameAvailabilityQueryError = ErrorType<Message>;

export function useKeyopollsProfileApiAuthCheckUsernameAvailability<
  TData = Awaited<ReturnType<typeof keyopollsProfileApiAuthCheckUsernameAvailability>>,
  TError = ErrorType<Message>,
>(
  username: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof keyopollsProfileApiAuthCheckUsernameAvailability>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof keyopollsProfileApiAuthCheckUsernameAvailability>>,
          TError,
          Awaited<ReturnType<typeof keyopollsProfileApiAuthCheckUsernameAvailability>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useKeyopollsProfileApiAuthCheckUsernameAvailability<
  TData = Awaited<ReturnType<typeof keyopollsProfileApiAuthCheckUsernameAvailability>>,
  TError = ErrorType<Message>,
>(
  username: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof keyopollsProfileApiAuthCheckUsernameAvailability>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof keyopollsProfileApiAuthCheckUsernameAvailability>>,
          TError,
          Awaited<ReturnType<typeof keyopollsProfileApiAuthCheckUsernameAvailability>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useKeyopollsProfileApiAuthCheckUsernameAvailability<
  TData = Awaited<ReturnType<typeof keyopollsProfileApiAuthCheckUsernameAvailability>>,
  TError = ErrorType<Message>,
>(
  username: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof keyopollsProfileApiAuthCheckUsernameAvailability>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Check Username Availability
 */

export function useKeyopollsProfileApiAuthCheckUsernameAvailability<
  TData = Awaited<ReturnType<typeof keyopollsProfileApiAuthCheckUsernameAvailability>>,
  TError = ErrorType<Message>,
>(
  username: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof keyopollsProfileApiAuthCheckUsernameAvailability>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getKeyopollsProfileApiAuthCheckUsernameAvailabilityQueryOptions(
    username,
    options
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create a new article.
Requires authentication.
 * @summary Create Article
 */
export const keyopollsArticlesApiCreateArticle = (
  keyopollsArticlesApiCreateArticleBody: BodyType<KeyopollsArticlesApiCreateArticleBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  const formData = new FormData();
  if (keyopollsArticlesApiCreateArticleBody.main_image !== undefined) {
    formData.append(`main_image`, keyopollsArticlesApiCreateArticleBody.main_image);
  }
  formData.append(`data`, JSON.stringify(keyopollsArticlesApiCreateArticleBody.data));

  return customInstance<ArticleDetails>(
    {
      url: `/api/articles/`,
      method: 'POST',
      headers: { 'Content-Type': 'multipart/form-data' },
      data: formData,
      signal,
    },
    options
  );
};

export const getKeyopollsArticlesApiCreateArticleMutationOptions = <
  TError = ErrorType<Message>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof keyopollsArticlesApiCreateArticle>>,
    TError,
    { data: BodyType<KeyopollsArticlesApiCreateArticleBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof keyopollsArticlesApiCreateArticle>>,
  TError,
  { data: BodyType<KeyopollsArticlesApiCreateArticleBody> },
  TContext
> => {
  const mutationKey = ['keyopollsArticlesApiCreateArticle'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof keyopollsArticlesApiCreateArticle>>,
    { data: BodyType<KeyopollsArticlesApiCreateArticleBody> }
  > = (props) => {
    const { data } = props ?? {};

    return keyopollsArticlesApiCreateArticle(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type KeyopollsArticlesApiCreateArticleMutationResult = NonNullable<
  Awaited<ReturnType<typeof keyopollsArticlesApiCreateArticle>>
>;
export type KeyopollsArticlesApiCreateArticleMutationBody =
  BodyType<KeyopollsArticlesApiCreateArticleBody>;
export type KeyopollsArticlesApiCreateArticleMutationError = ErrorType<Message>;

/**
 * @summary Create Article
 */
export const useKeyopollsArticlesApiCreateArticle = <
  TError = ErrorType<Message>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof keyopollsArticlesApiCreateArticle>>,
      TError,
      { data: BodyType<KeyopollsArticlesApiCreateArticleBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof keyopollsArticlesApiCreateArticle>>,
  TError,
  { data: BodyType<KeyopollsArticlesApiCreateArticleBody> },
  TContext
> => {
  const mutationOptions = getKeyopollsArticlesApiCreateArticleMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Get a paginated list of articles with comprehensive filtering options.

Features:
- Pagination with configurable page size
- Filter by community, creator, published status
- Search across title, subtitle, and content
- My articles filter for authenticated users
- Multiple sorting options
- Authentication-aware visibility (published vs drafts)

Query Parameters:
- page: Page number (default: 1)
- per_page: Items per page (default: 20, max: 100)
- community_id: Filter by community ID
- community_slug: Filter by community slug
- author_username: Filter by author username
- is_published: Filter by published status (true/false/null for all)
- my_articles: Show only current user's articles (requires auth)
- search: Search term for title, subtitle, or content
- order_by: Sort field (created_at, title with - for desc)
 * @summary List Articles
 */
export const keyopollsArticlesApiListArticles = (
  params?: KeyopollsArticlesApiListArticlesParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<ArticlesList>(
    { url: `/api/articles/`, method: 'GET', params, signal },
    options
  );
};

export const getKeyopollsArticlesApiListArticlesQueryKey = (
  params?: KeyopollsArticlesApiListArticlesParams
) => {
  return [`/api/articles/`, ...(params ? [params] : [])] as const;
};

export const getKeyopollsArticlesApiListArticlesQueryOptions = <
  TData = Awaited<ReturnType<typeof keyopollsArticlesApiListArticles>>,
  TError = ErrorType<Message>,
>(
  params?: KeyopollsArticlesApiListArticlesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof keyopollsArticlesApiListArticles>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getKeyopollsArticlesApiListArticlesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof keyopollsArticlesApiListArticles>>> = ({
    signal,
  }) => keyopollsArticlesApiListArticles(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof keyopollsArticlesApiListArticles>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type KeyopollsArticlesApiListArticlesQueryResult = NonNullable<
  Awaited<ReturnType<typeof keyopollsArticlesApiListArticles>>
>;
export type KeyopollsArticlesApiListArticlesQueryError = ErrorType<Message>;

export function useKeyopollsArticlesApiListArticles<
  TData = Awaited<ReturnType<typeof keyopollsArticlesApiListArticles>>,
  TError = ErrorType<Message>,
>(
  params: undefined | KeyopollsArticlesApiListArticlesParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof keyopollsArticlesApiListArticles>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof keyopollsArticlesApiListArticles>>,
          TError,
          Awaited<ReturnType<typeof keyopollsArticlesApiListArticles>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useKeyopollsArticlesApiListArticles<
  TData = Awaited<ReturnType<typeof keyopollsArticlesApiListArticles>>,
  TError = ErrorType<Message>,
>(
  params?: KeyopollsArticlesApiListArticlesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof keyopollsArticlesApiListArticles>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof keyopollsArticlesApiListArticles>>,
          TError,
          Awaited<ReturnType<typeof keyopollsArticlesApiListArticles>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useKeyopollsArticlesApiListArticles<
  TData = Awaited<ReturnType<typeof keyopollsArticlesApiListArticles>>,
  TError = ErrorType<Message>,
>(
  params?: KeyopollsArticlesApiListArticlesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof keyopollsArticlesApiListArticles>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List Articles
 */

export function useKeyopollsArticlesApiListArticles<
  TData = Awaited<ReturnType<typeof keyopollsArticlesApiListArticles>>,
  TError = ErrorType<Message>,
>(
  params?: KeyopollsArticlesApiListArticlesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof keyopollsArticlesApiListArticles>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getKeyopollsArticlesApiListArticlesQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Update an existing article.
Only the author can update their article.
 * @summary Update Article
 */
export const keyopollsArticlesApiUpdateArticle = (
  articleId: number,
  keyopollsArticlesApiUpdateArticleBody: BodyType<KeyopollsArticlesApiUpdateArticleBody>,
  options?: SecondParameter<typeof customInstance>
) => {
  const formData = new FormData();
  if (keyopollsArticlesApiUpdateArticleBody.main_image !== undefined) {
    formData.append(`main_image`, keyopollsArticlesApiUpdateArticleBody.main_image);
  }
  formData.append(`data`, JSON.stringify(keyopollsArticlesApiUpdateArticleBody.data));

  return customInstance<ArticleDetails>(
    {
      url: `/api/articles/${articleId}`,
      method: 'PUT',
      headers: { 'Content-Type': 'multipart/form-data' },
      data: formData,
    },
    options
  );
};

export const getKeyopollsArticlesApiUpdateArticleMutationOptions = <
  TError = ErrorType<Message>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof keyopollsArticlesApiUpdateArticle>>,
    TError,
    { articleId: number; data: BodyType<KeyopollsArticlesApiUpdateArticleBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof keyopollsArticlesApiUpdateArticle>>,
  TError,
  { articleId: number; data: BodyType<KeyopollsArticlesApiUpdateArticleBody> },
  TContext
> => {
  const mutationKey = ['keyopollsArticlesApiUpdateArticle'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof keyopollsArticlesApiUpdateArticle>>,
    { articleId: number; data: BodyType<KeyopollsArticlesApiUpdateArticleBody> }
  > = (props) => {
    const { articleId, data } = props ?? {};

    return keyopollsArticlesApiUpdateArticle(articleId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type KeyopollsArticlesApiUpdateArticleMutationResult = NonNullable<
  Awaited<ReturnType<typeof keyopollsArticlesApiUpdateArticle>>
>;
export type KeyopollsArticlesApiUpdateArticleMutationBody =
  BodyType<KeyopollsArticlesApiUpdateArticleBody>;
export type KeyopollsArticlesApiUpdateArticleMutationError = ErrorType<Message>;

/**
 * @summary Update Article
 */
export const useKeyopollsArticlesApiUpdateArticle = <
  TError = ErrorType<Message>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof keyopollsArticlesApiUpdateArticle>>,
      TError,
      { articleId: number; data: BodyType<KeyopollsArticlesApiUpdateArticleBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof keyopollsArticlesApiUpdateArticle>>,
  TError,
  { articleId: number; data: BodyType<KeyopollsArticlesApiUpdateArticleBody> },
  TContext
> => {
  const mutationOptions = getKeyopollsArticlesApiUpdateArticleMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Delete an article.
Only the author can delete their article.
 * @summary Delete Article
 */
export const keyopollsArticlesApiDeleteArticle = (
  articleId: number,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<Message>({ url: `/api/articles/${articleId}`, method: 'DELETE' }, options);
};

export const getKeyopollsArticlesApiDeleteArticleMutationOptions = <
  TError = ErrorType<Message>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof keyopollsArticlesApiDeleteArticle>>,
    TError,
    { articleId: number },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof keyopollsArticlesApiDeleteArticle>>,
  TError,
  { articleId: number },
  TContext
> => {
  const mutationKey = ['keyopollsArticlesApiDeleteArticle'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof keyopollsArticlesApiDeleteArticle>>,
    { articleId: number }
  > = (props) => {
    const { articleId } = props ?? {};

    return keyopollsArticlesApiDeleteArticle(articleId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type KeyopollsArticlesApiDeleteArticleMutationResult = NonNullable<
  Awaited<ReturnType<typeof keyopollsArticlesApiDeleteArticle>>
>;

export type KeyopollsArticlesApiDeleteArticleMutationError = ErrorType<Message>;

/**
 * @summary Delete Article
 */
export const useKeyopollsArticlesApiDeleteArticle = <
  TError = ErrorType<Message>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof keyopollsArticlesApiDeleteArticle>>,
      TError,
      { articleId: number },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof keyopollsArticlesApiDeleteArticle>>,
  TError,
  { articleId: number },
  TContext
> => {
  const mutationOptions = getKeyopollsArticlesApiDeleteArticleMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Get a specific article by ID.
Authentication is optional - provides additional context if authenticated.
 * @summary Get Article
 */
export const keyopollsArticlesApiGetArticle = (
  articleId: number,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<ArticleDetails>(
    { url: `/api/articles/${articleId}`, method: 'GET', signal },
    options
  );
};

export const getKeyopollsArticlesApiGetArticleQueryKey = (articleId: number) => {
  return [`/api/articles/${articleId}`] as const;
};

export const getKeyopollsArticlesApiGetArticleQueryOptions = <
  TData = Awaited<ReturnType<typeof keyopollsArticlesApiGetArticle>>,
  TError = ErrorType<Message>,
>(
  articleId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof keyopollsArticlesApiGetArticle>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getKeyopollsArticlesApiGetArticleQueryKey(articleId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof keyopollsArticlesApiGetArticle>>> = ({
    signal,
  }) => keyopollsArticlesApiGetArticle(articleId, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!articleId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof keyopollsArticlesApiGetArticle>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type KeyopollsArticlesApiGetArticleQueryResult = NonNullable<
  Awaited<ReturnType<typeof keyopollsArticlesApiGetArticle>>
>;
export type KeyopollsArticlesApiGetArticleQueryError = ErrorType<Message>;

export function useKeyopollsArticlesApiGetArticle<
  TData = Awaited<ReturnType<typeof keyopollsArticlesApiGetArticle>>,
  TError = ErrorType<Message>,
>(
  articleId: number,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof keyopollsArticlesApiGetArticle>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof keyopollsArticlesApiGetArticle>>,
          TError,
          Awaited<ReturnType<typeof keyopollsArticlesApiGetArticle>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useKeyopollsArticlesApiGetArticle<
  TData = Awaited<ReturnType<typeof keyopollsArticlesApiGetArticle>>,
  TError = ErrorType<Message>,
>(
  articleId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof keyopollsArticlesApiGetArticle>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof keyopollsArticlesApiGetArticle>>,
          TError,
          Awaited<ReturnType<typeof keyopollsArticlesApiGetArticle>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useKeyopollsArticlesApiGetArticle<
  TData = Awaited<ReturnType<typeof keyopollsArticlesApiGetArticle>>,
  TError = ErrorType<Message>,
>(
  articleId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof keyopollsArticlesApiGetArticle>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Article
 */

export function useKeyopollsArticlesApiGetArticle<
  TData = Awaited<ReturnType<typeof keyopollsArticlesApiGetArticle>>,
  TError = ErrorType<Message>,
>(
  articleId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof keyopollsArticlesApiGetArticle>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getKeyopollsArticlesApiGetArticleQueryOptions(articleId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Change the role of a community member.
Only the community creator can change member roles.

Available roles:
- member: Regular community member
- moderator: Can moderate content and manage members
- recruiter: Can invite new members
- creator: Cannot be assigned (only one creator per community)

Restrictions:
- Only community creator can change roles
- Cannot change creator role
- Cannot assign creator role to others
- Cannot change your own role
- Target user must be an active member of the community
 * @summary Change Member Role
 */
export const keyopollsCommunitiesApiAdminChangeMemberRole = (
  communityId: number,
  changeRoleRequestSchema: BodyType<ChangeRoleRequestSchema>,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<Message>(
    {
      url: `/api/communities/admin/communities/${communityId}/members/role`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: changeRoleRequestSchema,
    },
    options
  );
};

export const getKeyopollsCommunitiesApiAdminChangeMemberRoleMutationOptions = <
  TError = ErrorType<Message>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof keyopollsCommunitiesApiAdminChangeMemberRole>>,
    TError,
    { communityId: number; data: BodyType<ChangeRoleRequestSchema> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof keyopollsCommunitiesApiAdminChangeMemberRole>>,
  TError,
  { communityId: number; data: BodyType<ChangeRoleRequestSchema> },
  TContext
> => {
  const mutationKey = ['keyopollsCommunitiesApiAdminChangeMemberRole'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof keyopollsCommunitiesApiAdminChangeMemberRole>>,
    { communityId: number; data: BodyType<ChangeRoleRequestSchema> }
  > = (props) => {
    const { communityId, data } = props ?? {};

    return keyopollsCommunitiesApiAdminChangeMemberRole(communityId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type KeyopollsCommunitiesApiAdminChangeMemberRoleMutationResult = NonNullable<
  Awaited<ReturnType<typeof keyopollsCommunitiesApiAdminChangeMemberRole>>
>;
export type KeyopollsCommunitiesApiAdminChangeMemberRoleMutationBody =
  BodyType<ChangeRoleRequestSchema>;
export type KeyopollsCommunitiesApiAdminChangeMemberRoleMutationError = ErrorType<Message>;

/**
 * @summary Change Member Role
 */
export const useKeyopollsCommunitiesApiAdminChangeMemberRole = <
  TError = ErrorType<Message>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof keyopollsCommunitiesApiAdminChangeMemberRole>>,
      TError,
      { communityId: number; data: BodyType<ChangeRoleRequestSchema> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof keyopollsCommunitiesApiAdminChangeMemberRole>>,
  TError,
  { communityId: number; data: BodyType<ChangeRoleRequestSchema> },
  TContext
> => {
  const mutationOptions = getKeyopollsCommunitiesApiAdminChangeMemberRoleMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Get a paginated list of services with optional filtering.

Features:
- Search by service name or description
- Filter by community, creator, service type, broadcast, or status
- Pagination support
- Includes service attachments

Query Parameters:
- search: Search term for name or description
- community_id: Filter by community ID
- community_slug: Filter by community slug
- creator_id: Filter by service creator
- service_type: Filter by single service type (dm, live_chat, audio_call,
  video_call, custom, community_post, group_*)
- service_types: String of comma-separated service types for multiple filtering
- is_broadcasted: Filter by broadcast status (true/false)
- status: Filter by status (active, inactive, draft)
- page: Page number (default: 1)
- per_page: Items per page (default: 20, max: 100)
 * @summary Get Services
 */
export const keyopollsChatsApiServicesGetServices = (
  params?: KeyopollsChatsApiServicesGetServicesParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<ServicesListResponseSchema>(
    { url: `/api/services/services`, method: 'GET', params, signal },
    options
  );
};

export const getKeyopollsChatsApiServicesGetServicesQueryKey = (
  params?: KeyopollsChatsApiServicesGetServicesParams
) => {
  return [`/api/services/services`, ...(params ? [params] : [])] as const;
};

export const getKeyopollsChatsApiServicesGetServicesQueryOptions = <
  TData = Awaited<ReturnType<typeof keyopollsChatsApiServicesGetServices>>,
  TError = ErrorType<Message>,
>(
  params?: KeyopollsChatsApiServicesGetServicesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof keyopollsChatsApiServicesGetServices>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getKeyopollsChatsApiServicesGetServicesQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof keyopollsChatsApiServicesGetServices>>
  > = ({ signal }) => keyopollsChatsApiServicesGetServices(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof keyopollsChatsApiServicesGetServices>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type KeyopollsChatsApiServicesGetServicesQueryResult = NonNullable<
  Awaited<ReturnType<typeof keyopollsChatsApiServicesGetServices>>
>;
export type KeyopollsChatsApiServicesGetServicesQueryError = ErrorType<Message>;

export function useKeyopollsChatsApiServicesGetServices<
  TData = Awaited<ReturnType<typeof keyopollsChatsApiServicesGetServices>>,
  TError = ErrorType<Message>,
>(
  params: undefined | KeyopollsChatsApiServicesGetServicesParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof keyopollsChatsApiServicesGetServices>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof keyopollsChatsApiServicesGetServices>>,
          TError,
          Awaited<ReturnType<typeof keyopollsChatsApiServicesGetServices>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useKeyopollsChatsApiServicesGetServices<
  TData = Awaited<ReturnType<typeof keyopollsChatsApiServicesGetServices>>,
  TError = ErrorType<Message>,
>(
  params?: KeyopollsChatsApiServicesGetServicesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof keyopollsChatsApiServicesGetServices>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof keyopollsChatsApiServicesGetServices>>,
          TError,
          Awaited<ReturnType<typeof keyopollsChatsApiServicesGetServices>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useKeyopollsChatsApiServicesGetServices<
  TData = Awaited<ReturnType<typeof keyopollsChatsApiServicesGetServices>>,
  TError = ErrorType<Message>,
>(
  params?: KeyopollsChatsApiServicesGetServicesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof keyopollsChatsApiServicesGetServices>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Services
 */

export function useKeyopollsChatsApiServicesGetServices<
  TData = Awaited<ReturnType<typeof keyopollsChatsApiServicesGetServices>>,
  TError = ErrorType<Message>,
>(
  params?: KeyopollsChatsApiServicesGetServicesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof keyopollsChatsApiServicesGetServices>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getKeyopollsChatsApiServicesGetServicesQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create a new service. Only moderators can create services.

Required fields:
- community_slug: Slug of the community
- service_type: Type of service (dm, live_chat, audio_call, video_call, custom, community_post, group_*)
- name: Service name
- description: Service description
- price: Price in credits (minimum 0.00, 0 for free services)

Optional fields:
- duration_minutes: Duration for timed services (default: 10)
- is_duration_based: Whether service has time limit (default: False)
- status: Service status (default: active)
- attachments: List of files to attach to the service
- max_messages_a_day: For DM and custom services, max messages per day
- reply_time: For DM and custom services, reply time in days
- attachments_required: For custom services (always True), for community_post (always False)

Service creation limits:
- dm, live_chat, audio_call, video_call, group_*: Only one of each type per community per creator
- custom, community_post: Multiple services allowed per community per creator

Auto-broadcast rules:
- community_post, group_*: Always broadcasted
- Others: Not broadcasted
 * @summary Create Service
 */
export const keyopollsChatsApiServicesCreateService = (
  keyopollsChatsApiServicesCreateServiceBody: BodyType<KeyopollsChatsApiServicesCreateServiceBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  const formData = new FormData();
  if (keyopollsChatsApiServicesCreateServiceBody.attachments !== undefined) {
    keyopollsChatsApiServicesCreateServiceBody.attachments.forEach((value) =>
      formData.append(`attachments`, value)
    );
  }
  if (keyopollsChatsApiServicesCreateServiceBody.preview_image !== undefined) {
    formData.append(`preview_image`, keyopollsChatsApiServicesCreateServiceBody.preview_image);
  }
  formData.append(`data`, JSON.stringify(keyopollsChatsApiServicesCreateServiceBody.data));

  return customInstance<ServiceResponseSchema>(
    {
      url: `/api/services/services`,
      method: 'POST',
      headers: { 'Content-Type': 'multipart/form-data' },
      data: formData,
      signal,
    },
    options
  );
};

export const getKeyopollsChatsApiServicesCreateServiceMutationOptions = <
  TError = ErrorType<Message>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof keyopollsChatsApiServicesCreateService>>,
    TError,
    { data: BodyType<KeyopollsChatsApiServicesCreateServiceBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof keyopollsChatsApiServicesCreateService>>,
  TError,
  { data: BodyType<KeyopollsChatsApiServicesCreateServiceBody> },
  TContext
> => {
  const mutationKey = ['keyopollsChatsApiServicesCreateService'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof keyopollsChatsApiServicesCreateService>>,
    { data: BodyType<KeyopollsChatsApiServicesCreateServiceBody> }
  > = (props) => {
    const { data } = props ?? {};

    return keyopollsChatsApiServicesCreateService(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type KeyopollsChatsApiServicesCreateServiceMutationResult = NonNullable<
  Awaited<ReturnType<typeof keyopollsChatsApiServicesCreateService>>
>;
export type KeyopollsChatsApiServicesCreateServiceMutationBody =
  BodyType<KeyopollsChatsApiServicesCreateServiceBody>;
export type KeyopollsChatsApiServicesCreateServiceMutationError = ErrorType<Message>;

/**
 * @summary Create Service
 */
export const useKeyopollsChatsApiServicesCreateService = <
  TError = ErrorType<Message>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof keyopollsChatsApiServicesCreateService>>,
      TError,
      { data: BodyType<KeyopollsChatsApiServicesCreateServiceBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof keyopollsChatsApiServicesCreateService>>,
  TError,
  { data: BodyType<KeyopollsChatsApiServicesCreateServiceBody> },
  TContext
> => {
  const mutationOptions = getKeyopollsChatsApiServicesCreateServiceMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Get a single service by ID with all details and attachments.
 * @summary Get Service
 */
export const keyopollsChatsApiServicesGetService = (
  serviceId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<ServiceResponseSchema>(
    { url: `/api/services/services/${serviceId}`, method: 'GET', signal },
    options
  );
};

export const getKeyopollsChatsApiServicesGetServiceQueryKey = (serviceId: string) => {
  return [`/api/services/services/${serviceId}`] as const;
};

export const getKeyopollsChatsApiServicesGetServiceQueryOptions = <
  TData = Awaited<ReturnType<typeof keyopollsChatsApiServicesGetService>>,
  TError = ErrorType<Message>,
>(
  serviceId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof keyopollsChatsApiServicesGetService>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getKeyopollsChatsApiServicesGetServiceQueryKey(serviceId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof keyopollsChatsApiServicesGetService>>> = ({
    signal,
  }) => keyopollsChatsApiServicesGetService(serviceId, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!serviceId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof keyopollsChatsApiServicesGetService>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type KeyopollsChatsApiServicesGetServiceQueryResult = NonNullable<
  Awaited<ReturnType<typeof keyopollsChatsApiServicesGetService>>
>;
export type KeyopollsChatsApiServicesGetServiceQueryError = ErrorType<Message>;

export function useKeyopollsChatsApiServicesGetService<
  TData = Awaited<ReturnType<typeof keyopollsChatsApiServicesGetService>>,
  TError = ErrorType<Message>,
>(
  serviceId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof keyopollsChatsApiServicesGetService>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof keyopollsChatsApiServicesGetService>>,
          TError,
          Awaited<ReturnType<typeof keyopollsChatsApiServicesGetService>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useKeyopollsChatsApiServicesGetService<
  TData = Awaited<ReturnType<typeof keyopollsChatsApiServicesGetService>>,
  TError = ErrorType<Message>,
>(
  serviceId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof keyopollsChatsApiServicesGetService>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof keyopollsChatsApiServicesGetService>>,
          TError,
          Awaited<ReturnType<typeof keyopollsChatsApiServicesGetService>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useKeyopollsChatsApiServicesGetService<
  TData = Awaited<ReturnType<typeof keyopollsChatsApiServicesGetService>>,
  TError = ErrorType<Message>,
>(
  serviceId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof keyopollsChatsApiServicesGetService>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Service
 */

export function useKeyopollsChatsApiServicesGetService<
  TData = Awaited<ReturnType<typeof keyopollsChatsApiServicesGetService>>,
  TError = ErrorType<Message>,
>(
  serviceId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof keyopollsChatsApiServicesGetService>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getKeyopollsChatsApiServicesGetServiceQueryOptions(serviceId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Delete a service. Only the creator can delete their service.

This will permanently delete the service and all its attachments.
Consider setting status to 'inactive' instead if you want to preserve data.
 * @summary Delete Service
 */
export const keyopollsChatsApiServicesDeleteService = (
  serviceId: string,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<Message>(
    { url: `/api/services/services/${serviceId}`, method: 'DELETE' },
    options
  );
};

export const getKeyopollsChatsApiServicesDeleteServiceMutationOptions = <
  TError = ErrorType<Message>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof keyopollsChatsApiServicesDeleteService>>,
    TError,
    { serviceId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof keyopollsChatsApiServicesDeleteService>>,
  TError,
  { serviceId: string },
  TContext
> => {
  const mutationKey = ['keyopollsChatsApiServicesDeleteService'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof keyopollsChatsApiServicesDeleteService>>,
    { serviceId: string }
  > = (props) => {
    const { serviceId } = props ?? {};

    return keyopollsChatsApiServicesDeleteService(serviceId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type KeyopollsChatsApiServicesDeleteServiceMutationResult = NonNullable<
  Awaited<ReturnType<typeof keyopollsChatsApiServicesDeleteService>>
>;

export type KeyopollsChatsApiServicesDeleteServiceMutationError = ErrorType<Message>;

/**
 * @summary Delete Service
 */
export const useKeyopollsChatsApiServicesDeleteService = <
  TError = ErrorType<Message>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof keyopollsChatsApiServicesDeleteService>>,
      TError,
      { serviceId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof keyopollsChatsApiServicesDeleteService>>,
  TError,
  { serviceId: string },
  TContext
> => {
  const mutationOptions = getKeyopollsChatsApiServicesDeleteServiceMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Update an existing service. Only the creator can update their service.

Optional fields (only provided fields will be updated):
- name: Service name
- description: Service description
- price: Price in credits
- duration_minutes: Duration for timed services
- is_duration_based: Whether service has time limit
- status: Service status
- is_available: Whether service is available for purchase
- attachments_required: Whether service requires user attachments
- max_messages_a_day: For DM and custom services
- reply_time: For DM and custom services
- attachments: List of files to attach to the service
- replace_attachments: If True, replace all existing attachments. If False, add to existing ones.
 * @summary Update Service
 */
export const keyopollsChatsApiServicesUpdateService = (
  serviceId: string,
  keyopollsChatsApiServicesUpdateServiceBody: BodyType<KeyopollsChatsApiServicesUpdateServiceBody>,
  params?: KeyopollsChatsApiServicesUpdateServiceParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  const formData = new FormData();
  if (keyopollsChatsApiServicesUpdateServiceBody.attachments !== undefined) {
    keyopollsChatsApiServicesUpdateServiceBody.attachments.forEach((value) =>
      formData.append(`attachments`, value)
    );
  }
  if (keyopollsChatsApiServicesUpdateServiceBody.preview_image !== undefined) {
    formData.append(`preview_image`, keyopollsChatsApiServicesUpdateServiceBody.preview_image);
  }
  formData.append(`data`, JSON.stringify(keyopollsChatsApiServicesUpdateServiceBody.data));

  return customInstance<ServiceResponseSchema>(
    {
      url: `/api/services/services/update/${serviceId}`,
      method: 'POST',
      headers: { 'Content-Type': 'multipart/form-data' },
      data: formData,
      params,
      signal,
    },
    options
  );
};

export const getKeyopollsChatsApiServicesUpdateServiceMutationOptions = <
  TError = ErrorType<Message>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof keyopollsChatsApiServicesUpdateService>>,
    TError,
    {
      serviceId: string;
      data: BodyType<KeyopollsChatsApiServicesUpdateServiceBody>;
      params?: KeyopollsChatsApiServicesUpdateServiceParams;
    },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof keyopollsChatsApiServicesUpdateService>>,
  TError,
  {
    serviceId: string;
    data: BodyType<KeyopollsChatsApiServicesUpdateServiceBody>;
    params?: KeyopollsChatsApiServicesUpdateServiceParams;
  },
  TContext
> => {
  const mutationKey = ['keyopollsChatsApiServicesUpdateService'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof keyopollsChatsApiServicesUpdateService>>,
    {
      serviceId: string;
      data: BodyType<KeyopollsChatsApiServicesUpdateServiceBody>;
      params?: KeyopollsChatsApiServicesUpdateServiceParams;
    }
  > = (props) => {
    const { serviceId, data, params } = props ?? {};

    return keyopollsChatsApiServicesUpdateService(serviceId, data, params, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type KeyopollsChatsApiServicesUpdateServiceMutationResult = NonNullable<
  Awaited<ReturnType<typeof keyopollsChatsApiServicesUpdateService>>
>;
export type KeyopollsChatsApiServicesUpdateServiceMutationBody =
  BodyType<KeyopollsChatsApiServicesUpdateServiceBody>;
export type KeyopollsChatsApiServicesUpdateServiceMutationError = ErrorType<Message>;

/**
 * @summary Update Service
 */
export const useKeyopollsChatsApiServicesUpdateService = <
  TError = ErrorType<Message>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof keyopollsChatsApiServicesUpdateService>>,
      TError,
      {
        serviceId: string;
        data: BodyType<KeyopollsChatsApiServicesUpdateServiceBody>;
        params?: KeyopollsChatsApiServicesUpdateServiceParams;
      },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof keyopollsChatsApiServicesUpdateService>>,
  TError,
  {
    serviceId: string;
    data: BodyType<KeyopollsChatsApiServicesUpdateServiceBody>;
    params?: KeyopollsChatsApiServicesUpdateServiceParams;
  },
  TContext
> => {
  const mutationOptions = getKeyopollsChatsApiServicesUpdateServiceMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
